{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.executeOperation = executeOperation;\nconst error_1 = require(\"../error\");\nconst read_preference_1 = require(\"../read_preference\");\nconst server_selection_1 = require(\"../sdam/server_selection\");\nconst utils_1 = require(\"../utils\");\nconst operation_1 = require(\"./operation\");\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = error_1.MONGODB_ERROR_CODES.IllegalOperation;\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE = 'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\n/**\n * Executes the given operation with provided arguments.\n * @internal\n *\n * @remarks\n * Allows for a single point of entry to provide features such as implicit sessions, which\n * are required by the Driver Sessions specification in the event that a ClientSession is\n * not provided.\n *\n * The expectation is that this function:\n * - Connects the MongoClient if it has not already been connected, see {@link autoConnect}\n * - Creates a session if none is provided and cleans up the session it creates\n * - Tries an operation and retries under certain conditions, see {@link tryOperation}\n *\n * @typeParam T - The operation's type\n * @typeParam TResult - The type of the operation's result, calculated from T\n *\n * @param client - The MongoClient to execute this operation with\n * @param operation - The operation to execute\n */\nasync function executeOperation(client, operation) {\n  if (!(operation instanceof operation_1.AbstractOperation)) {\n    // TODO(NODE-3483): Extend MongoRuntimeError\n    throw new error_1.MongoRuntimeError('This method requires a valid operation instance');\n  }\n  const topology = await autoConnect(client);\n  // The driver sessions spec mandates that we implicitly create sessions for operations\n  // that are not explicitly provided with a session.\n  let session = operation.session;\n  let owner;\n  if (session == null) {\n    owner = Symbol();\n    session = client.startSession({\n      owner,\n      explicit: false\n    });\n  } else if (session.hasEnded) {\n    throw new error_1.MongoExpiredSessionError('Use of expired sessions is not permitted');\n  } else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {\n    throw new error_1.MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later');\n  } else if (session.client !== client) {\n    throw new error_1.MongoInvalidArgumentError('ClientSession must be from the same MongoClient');\n  }\n  if (session.explicit && session?.timeoutMS != null && operation.options.timeoutMS != null) {\n    throw new error_1.MongoInvalidArgumentError('Do not specify timeoutMS on operation if already specified on an explicit session');\n  }\n  const readPreference = operation.readPreference ?? read_preference_1.ReadPreference.primary;\n  const inTransaction = !!session?.inTransaction();\n  const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n  if (inTransaction && !readPreference.equals(read_preference_1.ReadPreference.primary) && (hasReadAspect || operation.commandName === 'runCommand')) {\n    throw new error_1.MongoTransactionError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`);\n  }\n  if (session?.isPinned && session.transaction.isCommitted && !operation.bypassPinningCheck) {\n    session.unpin();\n  }\n  try {\n    return await tryOperation(operation, {\n      topology,\n      session,\n      readPreference\n    });\n  } finally {\n    if (session?.owner != null && session.owner === owner) {\n      await session.endSession();\n    }\n  }\n}\n/**\n * Connects a client if it has not yet been connected\n * @internal\n */\nasync function autoConnect(client) {\n  if (client.topology == null) {\n    if (client.s.hasBeenClosed) {\n      throw new error_1.MongoNotConnectedError('Client must be connected before running operations');\n    }\n    client.s.options[Symbol.for('@@mdb.skipPingOnConnect')] = true;\n    try {\n      await client.connect();\n      if (client.topology == null) {\n        throw new error_1.MongoRuntimeError('client.connect did not create a topology but also did not throw');\n      }\n      return client.topology;\n    } finally {\n      delete client.s.options[Symbol.for('@@mdb.skipPingOnConnect')];\n    }\n  }\n  return client.topology;\n}\n/**\n * Executes an operation and retries as appropriate\n * @internal\n *\n * @remarks\n * Implements behaviour described in [Retryable Reads](https://github.com/mongodb/specifications/blob/master/source/retryable-reads/retryable-reads.md) and [Retryable\n * Writes](https://github.com/mongodb/specifications/blob/master/source/retryable-writes/retryable-writes.md) specification\n *\n * This function:\n * - performs initial server selection\n * - attempts to execute an operation\n * - retries the operation if it meets the criteria for a retryable read or a retryable write\n *\n * @typeParam T - The operation's type\n * @typeParam TResult - The type of the operation's result, calculated from T\n *\n * @param operation - The operation to execute\n * */\nasync function tryOperation(operation, {\n  topology,\n  session,\n  readPreference\n}) {\n  let selector;\n  if (operation.hasAspect(operation_1.Aspect.MUST_SELECT_SAME_SERVER)) {\n    // GetMore and KillCursor operations must always select the same server, but run through\n    // server selection to potentially force monitor checks if the server is\n    // in an unknown state.\n    selector = (0, server_selection_1.sameServerSelector)(operation.server?.description);\n  } else if (operation.trySecondaryWrite) {\n    // If operation should try to write to secondary use the custom server selector\n    // otherwise provide the read preference.\n    selector = (0, server_selection_1.secondaryWritableServerSelector)(topology.commonWireVersion, readPreference);\n  } else {\n    selector = readPreference;\n  }\n  let server = await topology.selectServer(selector, {\n    session,\n    operationName: operation.commandName\n  });\n  const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n  const hasWriteAspect = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);\n  const inTransaction = session?.inTransaction() ?? false;\n  const willRetryRead = topology.s.options.retryReads && !inTransaction && operation.canRetryRead;\n  const willRetryWrite = topology.s.options.retryWrites && !inTransaction && (0, utils_1.supportsRetryableWrites)(server) && operation.canRetryWrite;\n  const willRetry = operation.hasAspect(operation_1.Aspect.RETRYABLE) && session != null && (hasReadAspect && willRetryRead || hasWriteAspect && willRetryWrite);\n  if (hasWriteAspect && willRetryWrite && session != null) {\n    operation.options.willRetryWrite = true;\n    session.incrementTransactionNumber();\n  }\n  // TODO(NODE-6231): implement infinite retry within CSOT timeout here\n  const maxTries = willRetry ? 2 : 1;\n  let previousOperationError;\n  let previousServer;\n  // TODO(NODE-6231): implement infinite retry within CSOT timeout here\n  for (let tries = 0; tries < maxTries; tries++) {\n    if (previousOperationError) {\n      if (hasWriteAspect && previousOperationError.code === MMAPv1_RETRY_WRITES_ERROR_CODE) {\n        throw new error_1.MongoServerError({\n          message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n          errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n          originalError: previousOperationError\n        });\n      }\n      if (hasWriteAspect && !(0, error_1.isRetryableWriteError)(previousOperationError)) throw previousOperationError;\n      if (hasReadAspect && !(0, error_1.isRetryableReadError)(previousOperationError)) throw previousOperationError;\n      if (previousOperationError instanceof error_1.MongoNetworkError && operation.hasAspect(operation_1.Aspect.CURSOR_CREATING) && session != null && session.isPinned && !session.inTransaction()) {\n        session.unpin({\n          force: true,\n          forceClear: true\n        });\n      }\n      server = await topology.selectServer(selector, {\n        session,\n        operationName: operation.commandName,\n        previousServer\n      });\n      if (hasWriteAspect && !(0, utils_1.supportsRetryableWrites)(server)) {\n        throw new error_1.MongoUnexpectedServerResponseError('Selected server does not support retryable writes');\n      }\n    }\n    try {\n      return await operation.execute(server, session);\n    } catch (operationError) {\n      if (!(operationError instanceof error_1.MongoError)) throw operationError;\n      if (previousOperationError != null && operationError.hasErrorLabel(error_1.MongoErrorLabel.NoWritesPerformed)) {\n        throw previousOperationError;\n      }\n      previousServer = server.description;\n      previousOperationError = operationError;\n    }\n  }\n  throw previousOperationError ?? new error_1.MongoRuntimeError('Tried to propagate retryability error, but no error was found.');\n}","map":{"version":3,"names":["exports","executeOperation","error_1","require","read_preference_1","server_selection_1","utils_1","operation_1","MMAPv1_RETRY_WRITES_ERROR_CODE","MONGODB_ERROR_CODES","IllegalOperation","MMAPv1_RETRY_WRITES_ERROR_MESSAGE","client","operation","AbstractOperation","MongoRuntimeError","topology","autoConnect","session","owner","Symbol","startSession","explicit","hasEnded","MongoExpiredSessionError","snapshotEnabled","capabilities","supportsSnapshotReads","MongoCompatibilityError","MongoInvalidArgumentError","timeoutMS","options","readPreference","ReadPreference","primary","inTransaction","hasReadAspect","hasAspect","Aspect","READ_OPERATION","equals","commandName","MongoTransactionError","mode","isPinned","transaction","isCommitted","bypassPinningCheck","unpin","tryOperation","endSession","s","hasBeenClosed","MongoNotConnectedError","for","connect","selector","MUST_SELECT_SAME_SERVER","sameServerSelector","server","description","trySecondaryWrite","secondaryWritableServerSelector","commonWireVersion","selectServer","operationName","hasWriteAspect","WRITE_OPERATION","willRetryRead","retryReads","canRetryRead","willRetryWrite","retryWrites","supportsRetryableWrites","canRetryWrite","willRetry","RETRYABLE","incrementTransactionNumber","maxTries","previousOperationError","previousServer","tries","code","MongoServerError","message","errmsg","originalError","isRetryableWriteError","isRetryableReadError","MongoNetworkError","CURSOR_CREATING","force","forceClear","MongoUnexpectedServerResponseError","execute","operationError","MongoError","hasErrorLabel","MongoErrorLabel","NoWritesPerformed"],"sources":["/home/tobiya/node_modules/mongodb/src/operations/execute_operation.ts"],"sourcesContent":["import {\n  isRetryableReadError,\n  isRetryableWriteError,\n  MongoCompatibilityError,\n  MONGODB_ERROR_CODES,\n  MongoError,\n  MongoErrorLabel,\n  MongoExpiredSessionError,\n  MongoInvalidArgumentError,\n  MongoNetworkError,\n  MongoNotConnectedError,\n  MongoRuntimeError,\n  MongoServerError,\n  MongoTransactionError,\n  MongoUnexpectedServerResponseError\n} from '../error';\nimport type { MongoClient } from '../mongo_client';\nimport { ReadPreference } from '../read_preference';\nimport type { ServerDescription } from '../sdam/server_description';\nimport {\n  sameServerSelector,\n  secondaryWritableServerSelector,\n  type ServerSelector\n} from '../sdam/server_selection';\nimport type { Topology } from '../sdam/topology';\nimport type { ClientSession } from '../sessions';\nimport { supportsRetryableWrites } from '../utils';\nimport { AbstractOperation, Aspect } from './operation';\n\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = MONGODB_ERROR_CODES.IllegalOperation;\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE =\n  'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\n\ntype ResultTypeFromOperation<TOperation> =\n  TOperation extends AbstractOperation<infer K> ? K : never;\n\n/**\n * Executes the given operation with provided arguments.\n * @internal\n *\n * @remarks\n * Allows for a single point of entry to provide features such as implicit sessions, which\n * are required by the Driver Sessions specification in the event that a ClientSession is\n * not provided.\n *\n * The expectation is that this function:\n * - Connects the MongoClient if it has not already been connected, see {@link autoConnect}\n * - Creates a session if none is provided and cleans up the session it creates\n * - Tries an operation and retries under certain conditions, see {@link tryOperation}\n *\n * @typeParam T - The operation's type\n * @typeParam TResult - The type of the operation's result, calculated from T\n *\n * @param client - The MongoClient to execute this operation with\n * @param operation - The operation to execute\n */\nexport async function executeOperation<\n  T extends AbstractOperation<TResult>,\n  TResult = ResultTypeFromOperation<T>\n>(client: MongoClient, operation: T): Promise<TResult> {\n  if (!(operation instanceof AbstractOperation)) {\n    // TODO(NODE-3483): Extend MongoRuntimeError\n    throw new MongoRuntimeError('This method requires a valid operation instance');\n  }\n\n  const topology = await autoConnect(client);\n\n  // The driver sessions spec mandates that we implicitly create sessions for operations\n  // that are not explicitly provided with a session.\n  let session = operation.session;\n  let owner: symbol | undefined;\n\n  if (session == null) {\n    owner = Symbol();\n    session = client.startSession({ owner, explicit: false });\n  } else if (session.hasEnded) {\n    throw new MongoExpiredSessionError('Use of expired sessions is not permitted');\n  } else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {\n    throw new MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later');\n  } else if (session.client !== client) {\n    throw new MongoInvalidArgumentError('ClientSession must be from the same MongoClient');\n  }\n  if (session.explicit && session?.timeoutMS != null && operation.options.timeoutMS != null) {\n    throw new MongoInvalidArgumentError(\n      'Do not specify timeoutMS on operation if already specified on an explicit session'\n    );\n  }\n\n  const readPreference = operation.readPreference ?? ReadPreference.primary;\n  const inTransaction = !!session?.inTransaction();\n\n  const hasReadAspect = operation.hasAspect(Aspect.READ_OPERATION);\n\n  if (\n    inTransaction &&\n    !readPreference.equals(ReadPreference.primary) &&\n    (hasReadAspect || operation.commandName === 'runCommand')\n  ) {\n    throw new MongoTransactionError(\n      `Read preference in a transaction must be primary, not: ${readPreference.mode}`\n    );\n  }\n\n  if (session?.isPinned && session.transaction.isCommitted && !operation.bypassPinningCheck) {\n    session.unpin();\n  }\n\n  try {\n    return await tryOperation(operation, {\n      topology,\n      session,\n      readPreference\n    });\n  } finally {\n    if (session?.owner != null && session.owner === owner) {\n      await session.endSession();\n    }\n  }\n}\n\n/**\n * Connects a client if it has not yet been connected\n * @internal\n */\nasync function autoConnect(client: MongoClient): Promise<Topology> {\n  if (client.topology == null) {\n    if (client.s.hasBeenClosed) {\n      throw new MongoNotConnectedError('Client must be connected before running operations');\n    }\n    client.s.options[Symbol.for('@@mdb.skipPingOnConnect')] = true;\n    try {\n      await client.connect();\n      if (client.topology == null) {\n        throw new MongoRuntimeError(\n          'client.connect did not create a topology but also did not throw'\n        );\n      }\n      return client.topology;\n    } finally {\n      delete client.s.options[Symbol.for('@@mdb.skipPingOnConnect')];\n    }\n  }\n  return client.topology;\n}\n\n/** @internal */\ntype RetryOptions = {\n  session: ClientSession | undefined;\n  readPreference: ReadPreference;\n  topology: Topology;\n};\n\n/**\n * Executes an operation and retries as appropriate\n * @internal\n *\n * @remarks\n * Implements behaviour described in [Retryable Reads](https://github.com/mongodb/specifications/blob/master/source/retryable-reads/retryable-reads.md) and [Retryable\n * Writes](https://github.com/mongodb/specifications/blob/master/source/retryable-writes/retryable-writes.md) specification\n *\n * This function:\n * - performs initial server selection\n * - attempts to execute an operation\n * - retries the operation if it meets the criteria for a retryable read or a retryable write\n *\n * @typeParam T - The operation's type\n * @typeParam TResult - The type of the operation's result, calculated from T\n *\n * @param operation - The operation to execute\n * */\nasync function tryOperation<\n  T extends AbstractOperation<TResult>,\n  TResult = ResultTypeFromOperation<T>\n>(operation: T, { topology, session, readPreference }: RetryOptions): Promise<TResult> {\n  let selector: ReadPreference | ServerSelector;\n\n  if (operation.hasAspect(Aspect.MUST_SELECT_SAME_SERVER)) {\n    // GetMore and KillCursor operations must always select the same server, but run through\n    // server selection to potentially force monitor checks if the server is\n    // in an unknown state.\n    selector = sameServerSelector(operation.server?.description);\n  } else if (operation.trySecondaryWrite) {\n    // If operation should try to write to secondary use the custom server selector\n    // otherwise provide the read preference.\n    selector = secondaryWritableServerSelector(topology.commonWireVersion, readPreference);\n  } else {\n    selector = readPreference;\n  }\n\n  let server = await topology.selectServer(selector, {\n    session,\n    operationName: operation.commandName\n  });\n\n  const hasReadAspect = operation.hasAspect(Aspect.READ_OPERATION);\n  const hasWriteAspect = operation.hasAspect(Aspect.WRITE_OPERATION);\n  const inTransaction = session?.inTransaction() ?? false;\n\n  const willRetryRead = topology.s.options.retryReads && !inTransaction && operation.canRetryRead;\n\n  const willRetryWrite =\n    topology.s.options.retryWrites &&\n    !inTransaction &&\n    supportsRetryableWrites(server) &&\n    operation.canRetryWrite;\n\n  const willRetry =\n    operation.hasAspect(Aspect.RETRYABLE) &&\n    session != null &&\n    ((hasReadAspect && willRetryRead) || (hasWriteAspect && willRetryWrite));\n\n  if (hasWriteAspect && willRetryWrite && session != null) {\n    operation.options.willRetryWrite = true;\n    session.incrementTransactionNumber();\n  }\n\n  // TODO(NODE-6231): implement infinite retry within CSOT timeout here\n  const maxTries = willRetry ? 2 : 1;\n  let previousOperationError: MongoError | undefined;\n  let previousServer: ServerDescription | undefined;\n\n  // TODO(NODE-6231): implement infinite retry within CSOT timeout here\n  for (let tries = 0; tries < maxTries; tries++) {\n    if (previousOperationError) {\n      if (hasWriteAspect && previousOperationError.code === MMAPv1_RETRY_WRITES_ERROR_CODE) {\n        throw new MongoServerError({\n          message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n          errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n          originalError: previousOperationError\n        });\n      }\n\n      if (hasWriteAspect && !isRetryableWriteError(previousOperationError))\n        throw previousOperationError;\n\n      if (hasReadAspect && !isRetryableReadError(previousOperationError))\n        throw previousOperationError;\n\n      if (\n        previousOperationError instanceof MongoNetworkError &&\n        operation.hasAspect(Aspect.CURSOR_CREATING) &&\n        session != null &&\n        session.isPinned &&\n        !session.inTransaction()\n      ) {\n        session.unpin({ force: true, forceClear: true });\n      }\n\n      server = await topology.selectServer(selector, {\n        session,\n        operationName: operation.commandName,\n        previousServer\n      });\n\n      if (hasWriteAspect && !supportsRetryableWrites(server)) {\n        throw new MongoUnexpectedServerResponseError(\n          'Selected server does not support retryable writes'\n        );\n      }\n    }\n\n    try {\n      return await operation.execute(server, session);\n    } catch (operationError) {\n      if (!(operationError instanceof MongoError)) throw operationError;\n\n      if (\n        previousOperationError != null &&\n        operationError.hasErrorLabel(MongoErrorLabel.NoWritesPerformed)\n      ) {\n        throw previousOperationError;\n      }\n      previousServer = server.description;\n      previousOperationError = operationError;\n    }\n  }\n\n  throw (\n    previousOperationError ??\n    new MongoRuntimeError('Tried to propagate retryability error, but no error was found.')\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}