{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AbstractCursor = exports.CURSOR_FLAGS = void 0;\nconst stream_1 = require(\"stream\");\nconst bson_1 = require(\"../bson\");\nconst error_1 = require(\"../error\");\nconst mongo_types_1 = require(\"../mongo_types\");\nconst execute_operation_1 = require(\"../operations/execute_operation\");\nconst get_more_1 = require(\"../operations/get_more\");\nconst kill_cursors_1 = require(\"../operations/kill_cursors\");\nconst read_concern_1 = require(\"../read_concern\");\nconst read_preference_1 = require(\"../read_preference\");\nconst resource_management_1 = require(\"../resource_management\");\nconst sessions_1 = require(\"../sessions\");\nconst utils_1 = require(\"../utils\");\n/** @public */\nexports.CURSOR_FLAGS = ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'exhaust', 'partial'];\n/** @public */\nclass AbstractCursor extends mongo_types_1.TypedEventEmitter {\n  /** @internal */\n  constructor(client, namespace, options = {}) {\n    super();\n    /** @internal */\n    this.documents = null;\n    /** @internal */\n    this.hasEmittedClose = false;\n    if (!client.s.isMongoClient) {\n      throw new error_1.MongoRuntimeError('Cursor must be constructed with MongoClient');\n    }\n    this.cursorClient = client;\n    this.cursorNamespace = namespace;\n    this.cursorId = null;\n    this.initialized = false;\n    this.isClosed = false;\n    this.isKilled = false;\n    this.cursorOptions = {\n      readPreference: options.readPreference && options.readPreference instanceof read_preference_1.ReadPreference ? options.readPreference : read_preference_1.ReadPreference.primary,\n      ...(0, bson_1.pluckBSONSerializeOptions)(options)\n    };\n    this.cursorOptions.timeoutMS = options.timeoutMS;\n    const readConcern = read_concern_1.ReadConcern.fromOptions(options);\n    if (readConcern) {\n      this.cursorOptions.readConcern = readConcern;\n    }\n    if (typeof options.batchSize === 'number') {\n      this.cursorOptions.batchSize = options.batchSize;\n    }\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (options.comment !== undefined) {\n      this.cursorOptions.comment = options.comment;\n    }\n    if (typeof options.maxTimeMS === 'number') {\n      this.cursorOptions.maxTimeMS = options.maxTimeMS;\n    }\n    if (typeof options.maxAwaitTimeMS === 'number') {\n      this.cursorOptions.maxAwaitTimeMS = options.maxAwaitTimeMS;\n    }\n    if (options.session instanceof sessions_1.ClientSession) {\n      this.cursorSession = options.session;\n    } else {\n      this.cursorSession = this.cursorClient.startSession({\n        owner: this,\n        explicit: false\n      });\n    }\n    this.deserializationOptions = {\n      ...this.cursorOptions,\n      validation: {\n        utf8: options?.enableUtf8Validation === false ? false : true\n      }\n    };\n  }\n  /**\n   * The cursor has no id until it receives a response from the initial cursor creating command.\n   *\n   * It is non-zero for as long as the database has an open cursor.\n   *\n   * The initiating command may receive a zero id if the entire result is in the `firstBatch`.\n   */\n  get id() {\n    return this.cursorId ?? undefined;\n  }\n  /** @internal */\n  get isDead() {\n    return (this.cursorId?.isZero() ?? false) || this.isClosed || this.isKilled;\n  }\n  /** @internal */\n  get client() {\n    return this.cursorClient;\n  }\n  /** @internal */\n  get server() {\n    return this.selectedServer;\n  }\n  get namespace() {\n    return this.cursorNamespace;\n  }\n  get readPreference() {\n    return this.cursorOptions.readPreference;\n  }\n  get readConcern() {\n    return this.cursorOptions.readConcern;\n  }\n  /** @internal */\n  get session() {\n    return this.cursorSession;\n  }\n  set session(clientSession) {\n    this.cursorSession = clientSession;\n  }\n  /**\n   * The cursor is closed and all remaining locally buffered documents have been iterated.\n   */\n  get closed() {\n    return this.isClosed && (this.documents?.length ?? 0) === 0;\n  }\n  /**\n   * A `killCursors` command was attempted on this cursor.\n   * This is performed if the cursor id is non zero.\n   */\n  get killed() {\n    return this.isKilled;\n  }\n  get loadBalanced() {\n    return !!this.cursorClient.topology?.loadBalanced;\n  }\n  /** @internal */\n  async asyncDispose() {\n    await this.close();\n  }\n  /** Returns current buffered documents length */\n  bufferedCount() {\n    return this.documents?.length ?? 0;\n  }\n  /** Returns current buffered documents */\n  readBufferedDocuments(number) {\n    const bufferedDocs = [];\n    const documentsToRead = Math.min(number ?? this.documents?.length ?? 0, this.documents?.length ?? 0);\n    for (let count = 0; count < documentsToRead; count++) {\n      const document = this.documents?.shift(this.deserializationOptions);\n      if (document != null) {\n        bufferedDocs.push(document);\n      }\n    }\n    return bufferedDocs;\n  }\n  async *[Symbol.asyncIterator]() {\n    if (this.closed) {\n      return;\n    }\n    try {\n      while (true) {\n        if (this.isKilled) {\n          return;\n        }\n        if (this.closed) {\n          return;\n        }\n        if (this.cursorId != null && this.isDead && (this.documents?.length ?? 0) === 0) {\n          return;\n        }\n        const document = await this.next();\n        // eslint-disable-next-line no-restricted-syntax\n        if (document === null) {\n          return;\n        }\n        yield document;\n      }\n    } finally {\n      // Only close the cursor if it has not already been closed. This finally clause handles\n      // the case when a user would break out of a for await of loop early.\n      if (!this.isClosed) {\n        try {\n          await this.close();\n        } catch (error) {\n          (0, utils_1.squashError)(error);\n        }\n      }\n    }\n  }\n  stream(options) {\n    if (options?.transform) {\n      const transform = options.transform;\n      const readable = new ReadableCursorStream(this);\n      const transformedStream = readable.pipe(new stream_1.Transform({\n        objectMode: true,\n        highWaterMark: 1,\n        transform(chunk, _, callback) {\n          try {\n            const transformed = transform(chunk);\n            callback(undefined, transformed);\n          } catch (err) {\n            callback(err);\n          }\n        }\n      }));\n      // Bubble errors to transformed stream, because otherwise no way\n      // to handle this error.\n      readable.on('error', err => transformedStream.emit('error', err));\n      return transformedStream;\n    }\n    return new ReadableCursorStream(this);\n  }\n  async hasNext() {\n    if (this.cursorId === bson_1.Long.ZERO) {\n      return false;\n    }\n    do {\n      if ((this.documents?.length ?? 0) !== 0) {\n        return true;\n      }\n      await this.fetchBatch();\n    } while (!this.isDead || (this.documents?.length ?? 0) !== 0);\n    return false;\n  }\n  /** Get the next available document from the cursor, returns null if no more documents are available. */\n  async next() {\n    if (this.cursorId === bson_1.Long.ZERO) {\n      throw new error_1.MongoCursorExhaustedError();\n    }\n    do {\n      const doc = this.documents?.shift(this.deserializationOptions);\n      if (doc != null) {\n        if (this.transform != null) return await this.transformDocument(doc);\n        return doc;\n      }\n      await this.fetchBatch();\n    } while (!this.isDead || (this.documents?.length ?? 0) !== 0);\n    return null;\n  }\n  /**\n   * Try to get the next available document from the cursor or `null` if an empty batch is returned\n   */\n  async tryNext() {\n    if (this.cursorId === bson_1.Long.ZERO) {\n      throw new error_1.MongoCursorExhaustedError();\n    }\n    let doc = this.documents?.shift(this.deserializationOptions);\n    if (doc != null) {\n      if (this.transform != null) return await this.transformDocument(doc);\n      return doc;\n    }\n    await this.fetchBatch();\n    doc = this.documents?.shift(this.deserializationOptions);\n    if (doc != null) {\n      if (this.transform != null) return await this.transformDocument(doc);\n      return doc;\n    }\n    return null;\n  }\n  /**\n   * Iterates over all the documents for this cursor using the iterator, callback pattern.\n   *\n   * If the iterator returns `false`, iteration will stop.\n   *\n   * @param iterator - The iteration callback.\n   * @deprecated - Will be removed in a future release. Use for await...of instead.\n   */\n  async forEach(iterator) {\n    if (typeof iterator !== 'function') {\n      throw new error_1.MongoInvalidArgumentError('Argument \"iterator\" must be a function');\n    }\n    for await (const document of this) {\n      const result = iterator(document);\n      if (result === false) {\n        break;\n      }\n    }\n  }\n  /**\n   * Frees any client-side resources used by the cursor.\n   */\n  async close() {\n    await this.cleanup();\n  }\n  /**\n   * Returns an array of documents. The caller is responsible for making sure that there\n   * is enough memory to store the results. Note that the array only contains partial\n   * results when this cursor had been previously accessed. In that case,\n   * cursor.rewind() can be used to reset the cursor.\n   */\n  async toArray() {\n    const array = [];\n    // at the end of the loop (since readBufferedDocuments is called) the buffer will be empty\n    // then, the 'await of' syntax will run a getMore call\n    for await (const document of this) {\n      array.push(document);\n      const docs = this.readBufferedDocuments();\n      if (this.transform != null) {\n        for (const doc of docs) {\n          array.push(await this.transformDocument(doc));\n        }\n      } else {\n        array.push(...docs);\n      }\n    }\n    return array;\n  }\n  /**\n   * Add a cursor flag to the cursor\n   *\n   * @param flag - The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial' -.\n   * @param value - The flag boolean value.\n   */\n  addCursorFlag(flag, value) {\n    this.throwIfInitialized();\n    if (!exports.CURSOR_FLAGS.includes(flag)) {\n      throw new error_1.MongoInvalidArgumentError(`Flag ${flag} is not one of ${exports.CURSOR_FLAGS}`);\n    }\n    if (typeof value !== 'boolean') {\n      throw new error_1.MongoInvalidArgumentError(`Flag ${flag} must be a boolean value`);\n    }\n    this.cursorOptions[flag] = value;\n    return this;\n  }\n  /**\n   * Map all documents using the provided function\n   * If there is a transform set on the cursor, that will be called first and the result passed to\n   * this function's transform.\n   *\n   * @remarks\n   *\n   * **Note** Cursors use `null` internally to indicate that there are no more documents in the cursor. Providing a mapping\n   * function that maps values to `null` will result in the cursor closing itself before it has finished iterating\n   * all documents.  This will **not** result in a memory leak, just surprising behavior.  For example:\n   *\n   * ```typescript\n   * const cursor = collection.find({});\n   * cursor.map(() => null);\n   *\n   * const documents = await cursor.toArray();\n   * // documents is always [], regardless of how many documents are in the collection.\n   * ```\n   *\n   * Other falsey values are allowed:\n   *\n   * ```typescript\n   * const cursor = collection.find({});\n   * cursor.map(() => '');\n   *\n   * const documents = await cursor.toArray();\n   * // documents is now an array of empty strings\n   * ```\n   *\n   * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\n   * it **does not** return a new instance of a cursor. This means when calling map,\n   * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\n   * Take note of the following example:\n   *\n   * @example\n   * ```typescript\n   * const cursor: FindCursor<Document> = coll.find();\n   * const mappedCursor: FindCursor<number> = cursor.map(doc => Object.keys(doc).length);\n   * const keyCounts: number[] = await mappedCursor.toArray(); // cursor.toArray() still returns Document[]\n   * ```\n   * @param transform - The mapping transformation method.\n   */\n  map(transform) {\n    this.throwIfInitialized();\n    const oldTransform = this.transform;\n    if (oldTransform) {\n      this.transform = doc => {\n        return transform(oldTransform(doc));\n      };\n    } else {\n      this.transform = transform;\n    }\n    return this;\n  }\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n  withReadPreference(readPreference) {\n    this.throwIfInitialized();\n    if (readPreference instanceof read_preference_1.ReadPreference) {\n      this.cursorOptions.readPreference = readPreference;\n    } else if (typeof readPreference === 'string') {\n      this.cursorOptions.readPreference = read_preference_1.ReadPreference.fromString(readPreference);\n    } else {\n      throw new error_1.MongoInvalidArgumentError(`Invalid read preference: ${readPreference}`);\n    }\n    return this;\n  }\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n  withReadConcern(readConcern) {\n    this.throwIfInitialized();\n    const resolvedReadConcern = read_concern_1.ReadConcern.fromOptions({\n      readConcern\n    });\n    if (resolvedReadConcern) {\n      this.cursorOptions.readConcern = resolvedReadConcern;\n    }\n    return this;\n  }\n  /**\n   * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)\n   *\n   * @param value - Number of milliseconds to wait before aborting the query.\n   */\n  maxTimeMS(value) {\n    this.throwIfInitialized();\n    if (typeof value !== 'number') {\n      throw new error_1.MongoInvalidArgumentError('Argument for maxTimeMS must be a number');\n    }\n    this.cursorOptions.maxTimeMS = value;\n    return this;\n  }\n  /**\n   * Set the batch size for the cursor.\n   *\n   * @param value - The number of documents to return per batch. See {@link https://www.mongodb.com/docs/manual/reference/command/find/|find command documentation}.\n   */\n  batchSize(value) {\n    this.throwIfInitialized();\n    if (this.cursorOptions.tailable) {\n      throw new error_1.MongoTailableCursorError('Tailable cursor does not support batchSize');\n    }\n    if (typeof value !== 'number') {\n      throw new error_1.MongoInvalidArgumentError('Operation \"batchSize\" requires an integer');\n    }\n    this.cursorOptions.batchSize = value;\n    return this;\n  }\n  /**\n   * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will\n   * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even\n   * if the resultant data has already been retrieved by this cursor.\n   */\n  rewind() {\n    if (!this.initialized) {\n      return;\n    }\n    this.cursorId = null;\n    this.documents?.clear();\n    this.isClosed = false;\n    this.isKilled = false;\n    this.initialized = false;\n    const session = this.cursorSession;\n    if (session) {\n      // We only want to end this session if we created it, and it hasn't ended yet\n      if (session.explicit === false) {\n        if (!session.hasEnded) {\n          session.endSession().then(undefined, utils_1.squashError);\n        }\n        this.cursorSession = this.cursorClient.startSession({\n          owner: this,\n          explicit: false\n        });\n      }\n    }\n  }\n  /** @internal */\n  async getMore(batchSize) {\n    if (this.cursorId == null) {\n      throw new error_1.MongoRuntimeError('Unexpected null cursor id. A cursor creating command should have set this');\n    }\n    if (this.selectedServer == null) {\n      throw new error_1.MongoRuntimeError('Unexpected null selectedServer. A cursor creating command should have set this');\n    }\n    const getMoreOperation = new get_more_1.GetMoreOperation(this.cursorNamespace, this.cursorId, this.selectedServer, {\n      ...this.cursorOptions,\n      session: this.cursorSession,\n      batchSize\n    });\n    return await (0, execute_operation_1.executeOperation)(this.cursorClient, getMoreOperation);\n  }\n  /**\n   * @internal\n   *\n   * This function is exposed for the unified test runner's createChangeStream\n   * operation.  We cannot refactor to use the abstract _initialize method without\n   * a significant refactor.\n   */\n  async cursorInit() {\n    try {\n      const state = await this._initialize(this.cursorSession);\n      const response = state.response;\n      this.selectedServer = state.server;\n      this.cursorId = response.id;\n      this.cursorNamespace = response.ns ?? this.namespace;\n      this.documents = response;\n      this.initialized = true; // the cursor is now initialized, even if it is dead\n    } catch (error) {\n      // the cursor is now initialized, even if an error occurred\n      this.initialized = true;\n      await this.cleanup(error);\n      throw error;\n    }\n    if (this.isDead) {\n      await this.cleanup();\n    }\n    return;\n  }\n  /** @internal Attempt to obtain more documents */\n  async fetchBatch() {\n    if (this.isClosed) {\n      return;\n    }\n    if (this.isDead) {\n      // if the cursor is dead, we clean it up\n      // cleanupCursor should never throw, but if it does it indicates a bug in the driver\n      // and we should surface the error\n      await this.cleanup();\n      return;\n    }\n    if (this.cursorId == null) {\n      await this.cursorInit();\n      // If the cursor died or returned documents, return\n      if ((this.documents?.length ?? 0) !== 0 || this.isDead) return;\n      // Otherwise, run a getMore\n    }\n    // otherwise need to call getMore\n    const batchSize = this.cursorOptions.batchSize || 1000;\n    try {\n      const response = await this.getMore(batchSize);\n      this.cursorId = response.id;\n      this.documents = response;\n    } catch (error) {\n      try {\n        await this.cleanup(error);\n      } catch (error) {\n        // `cleanupCursor` should never throw, squash and throw the original error\n        (0, utils_1.squashError)(error);\n      }\n      throw error;\n    }\n    if (this.isDead) {\n      // If we successfully received a response from a cursor BUT the cursor indicates that it is exhausted,\n      // we intentionally clean up the cursor to release its session back into the pool before the cursor\n      // is iterated.  This prevents a cursor that is exhausted on the server from holding\n      // onto a session indefinitely until the AbstractCursor is iterated.\n      //\n      // cleanupCursorAsync should never throw, but if it does it indicates a bug in the driver\n      // and we should surface the error\n      await this.cleanup();\n    }\n  }\n  /** @internal */\n  async cleanup(error) {\n    this.isClosed = true;\n    const session = this.cursorSession;\n    try {\n      if (!this.isKilled && this.cursorId && !this.cursorId.isZero() && this.cursorNamespace && this.selectedServer && !session.hasEnded) {\n        this.isKilled = true;\n        const cursorId = this.cursorId;\n        this.cursorId = bson_1.Long.ZERO;\n        await (0, execute_operation_1.executeOperation)(this.cursorClient, new kill_cursors_1.KillCursorsOperation(cursorId, this.cursorNamespace, this.selectedServer, {\n          session\n        }));\n      }\n    } catch (error) {\n      (0, utils_1.squashError)(error);\n    } finally {\n      if (session?.owner === this) {\n        await session.endSession({\n          error\n        });\n      }\n      if (!session?.inTransaction()) {\n        (0, sessions_1.maybeClearPinnedConnection)(session, {\n          error\n        });\n      }\n      this.emitClose();\n    }\n  }\n  /** @internal */\n  emitClose() {\n    try {\n      if (!this.hasEmittedClose && ((this.documents?.length ?? 0) === 0 || this.isClosed)) {\n        // @ts-expect-error: CursorEvents is generic so Parameters<CursorEvents[\"close\"]> may not be assignable to `[]`. Not sure how to require extenders do not add parameters.\n        this.emit('close');\n      }\n    } finally {\n      this.hasEmittedClose = true;\n    }\n  }\n  /** @internal */\n  async transformDocument(document) {\n    if (this.transform == null) return document;\n    try {\n      const transformedDocument = this.transform(document);\n      // eslint-disable-next-line no-restricted-syntax\n      if (transformedDocument === null) {\n        const TRANSFORM_TO_NULL_ERROR = 'Cursor returned a `null` document, but the cursor is not exhausted.  Mapping documents to `null` is not supported in the cursor transform.';\n        throw new error_1.MongoAPIError(TRANSFORM_TO_NULL_ERROR);\n      }\n      return transformedDocument;\n    } catch (transformError) {\n      try {\n        await this.close();\n      } catch (closeError) {\n        (0, utils_1.squashError)(closeError);\n      }\n      throw transformError;\n    }\n  }\n  /** @internal */\n  throwIfInitialized() {\n    if (this.initialized) throw new error_1.MongoCursorInUseError();\n  }\n}\nexports.AbstractCursor = AbstractCursor;\n/** @event */\nAbstractCursor.CLOSE = 'close';\nclass ReadableCursorStream extends stream_1.Readable {\n  constructor(cursor) {\n    super({\n      objectMode: true,\n      autoDestroy: false,\n      highWaterMark: 1\n    });\n    this._readInProgress = false;\n    this._cursor = cursor;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _read(size) {\n    if (!this._readInProgress) {\n      this._readInProgress = true;\n      this._readNext();\n    }\n  }\n  _destroy(error, callback) {\n    this._cursor.close().then(() => callback(error), closeError => callback(closeError));\n  }\n  _readNext() {\n    if (this._cursor.id === bson_1.Long.ZERO) {\n      this.push(null);\n      return;\n    }\n    this._cursor.next().then(result => {\n      if (result == null) {\n        this.push(null);\n      } else if (this.destroyed) {\n        this._cursor.close().then(undefined, utils_1.squashError);\n      } else {\n        if (this.push(result)) {\n          return this._readNext();\n        }\n        this._readInProgress = false;\n      }\n    }, err => {\n      // NOTE: This is questionable, but we have a test backing the behavior. It seems the\n      //       desired behavior is that a stream ends cleanly when a user explicitly closes\n      //       a client during iteration. Alternatively, we could do the \"right\" thing and\n      //       propagate the error message by removing this special case.\n      if (err.message.match(/server is closed/)) {\n        this._cursor.close().then(undefined, utils_1.squashError);\n        return this.push(null);\n      }\n      // NOTE: This is also perhaps questionable. The rationale here is that these errors tend\n      //       to be \"operation was interrupted\", where a cursor has been closed but there is an\n      //       active getMore in-flight. This used to check if the cursor was killed but once\n      //       that changed to happen in cleanup legitimate errors would not destroy the\n      //       stream. There are change streams test specifically test these cases.\n      if (err.message.match(/operation was interrupted/)) {\n        return this.push(null);\n      }\n      // NOTE: The two above checks on the message of the error will cause a null to be pushed\n      //       to the stream, thus closing the stream before the destroy call happens. This means\n      //       that either of those error messages on a change stream will not get a proper\n      //       'error' event to be emitted (the error passed to destroy). Change stream resumability\n      //       relies on that error event to be emitted to create its new cursor and thus was not\n      //       working on 4.4 servers because the error emitted on failover was \"interrupted at\n      //       shutdown\" while on 5.0+ it is \"The server is in quiesce mode and will shut down\".\n      //       See NODE-4475.\n      return this.destroy(err);\n    });\n  }\n}\n(0, resource_management_1.configureResourceManagement)(AbstractCursor.prototype);","map":{"version":3,"names":["stream_1","require","bson_1","error_1","mongo_types_1","execute_operation_1","get_more_1","kill_cursors_1","read_concern_1","read_preference_1","resource_management_1","sessions_1","utils_1","exports","CURSOR_FLAGS","AbstractCursor","TypedEventEmitter","constructor","client","namespace","options","documents","hasEmittedClose","s","isMongoClient","MongoRuntimeError","cursorClient","cursorNamespace","cursorId","initialized","isClosed","isKilled","cursorOptions","readPreference","ReadPreference","primary","pluckBSONSerializeOptions","timeoutMS","readConcern","ReadConcern","fromOptions","batchSize","comment","undefined","maxTimeMS","maxAwaitTimeMS","session","ClientSession","cursorSession","startSession","owner","explicit","deserializationOptions","validation","utf8","enableUtf8Validation","id","isDead","isZero","server","selectedServer","clientSession","closed","length","killed","loadBalanced","topology","asyncDispose","close","bufferedCount","readBufferedDocuments","number","bufferedDocs","documentsToRead","Math","min","count","document","shift","push","Symbol","asyncIterator","next","error","squashError","stream","transform","readable","ReadableCursorStream","transformedStream","pipe","Transform","objectMode","highWaterMark","chunk","_","callback","transformed","err","on","emit","hasNext","Long","ZERO","fetchBatch","MongoCursorExhaustedError","doc","transformDocument","tryNext","forEach","iterator","MongoInvalidArgumentError","result","cleanup","toArray","array","docs","addCursorFlag","flag","value","throwIfInitialized","includes","map","oldTransform","withReadPreference","fromString","withReadConcern","resolvedReadConcern","tailable","MongoTailableCursorError","rewind","clear","hasEnded","endSession","then","getMore","getMoreOperation","GetMoreOperation","executeOperation","cursorInit","state","_initialize","response","ns","KillCursorsOperation","inTransaction","maybeClearPinnedConnection","emitClose","transformedDocument","TRANSFORM_TO_NULL_ERROR","MongoAPIError","transformError","closeError","MongoCursorInUseError","CLOSE","Readable","cursor","autoDestroy","_readInProgress","_cursor","_read","size","_readNext","_destroy","destroyed","message","match","destroy","configureResourceManagement","prototype"],"sources":["/home/tobiya/node_modules/mongodb/src/cursor/abstract_cursor.ts"],"sourcesContent":["import { Readable, Transform } from 'stream';\n\nimport { type BSONSerializeOptions, type Document, Long, pluckBSONSerializeOptions } from '../bson';\nimport { type OnDemandDocumentDeserializeOptions } from '../cmap/wire_protocol/on_demand/document';\nimport { type CursorResponse } from '../cmap/wire_protocol/responses';\nimport {\n  MongoAPIError,\n  MongoCursorExhaustedError,\n  MongoCursorInUseError,\n  MongoInvalidArgumentError,\n  MongoRuntimeError,\n  MongoTailableCursorError\n} from '../error';\nimport type { MongoClient } from '../mongo_client';\nimport { TypedEventEmitter } from '../mongo_types';\nimport { executeOperation } from '../operations/execute_operation';\nimport { GetMoreOperation } from '../operations/get_more';\nimport { KillCursorsOperation } from '../operations/kill_cursors';\nimport { ReadConcern, type ReadConcernLike } from '../read_concern';\nimport { ReadPreference, type ReadPreferenceLike } from '../read_preference';\nimport { type AsyncDisposable, configureResourceManagement } from '../resource_management';\nimport type { Server } from '../sdam/server';\nimport { ClientSession, maybeClearPinnedConnection } from '../sessions';\nimport { type MongoDBNamespace, squashError } from '../utils';\n\n/**\n * @internal\n * TODO(NODE-2882): A cursor's getMore commands must be run on the same server it was started on\n * and the same session must be used for the lifetime of the cursor. This object serves to get the\n * server and session (along with the response) out of executeOperation back to the AbstractCursor.\n *\n * There may be a better design for communicating these values back to the cursor, currently an operation\n * MUST store the selected server on itself so it can be read after executeOperation has returned.\n */\nexport interface InitialCursorResponse {\n  /** The server selected for the operation */\n  server: Server;\n  /** The session used for this operation, may be implicitly created */\n  session?: ClientSession;\n  /** The raw server response for the operation */\n  response: CursorResponse;\n}\n\n/** @public */\nexport const CURSOR_FLAGS = [\n  'tailable',\n  'oplogReplay',\n  'noCursorTimeout',\n  'awaitData',\n  'exhaust',\n  'partial'\n] as const;\n\n/** @public */\nexport interface CursorStreamOptions {\n  /** A transformation method applied to each document emitted by the stream */\n  transform?(this: void, doc: Document): Document;\n}\n\n/** @public */\nexport type CursorFlag = (typeof CURSOR_FLAGS)[number];\n\n/** @public */\nexport interface AbstractCursorOptions extends BSONSerializeOptions {\n  session?: ClientSession;\n  readPreference?: ReadPreferenceLike;\n  readConcern?: ReadConcernLike;\n  /**\n   * Specifies the number of documents to return in each response from MongoDB\n   */\n  batchSize?: number;\n  /**\n   * When applicable `maxTimeMS` controls the amount of time the initial command\n   * that constructs a cursor should take. (ex. find, aggregate, listCollections)\n   */\n  maxTimeMS?: number;\n  /**\n   * When applicable `maxAwaitTimeMS` controls the amount of time subsequent getMores\n   * that a cursor uses to fetch more data should take. (ex. cursor.next())\n   */\n  maxAwaitTimeMS?: number;\n  /**\n   * Comment to apply to the operation.\n   *\n   * In server versions pre-4.4, 'comment' must be string.  A server\n   * error will be thrown if any other type is provided.\n   *\n   * In server versions 4.4 and above, 'comment' can be any valid BSON type.\n   */\n  comment?: unknown;\n  /**\n   * By default, MongoDB will automatically close a cursor when the\n   * client has exhausted all results in the cursor. However, for [capped collections](https://www.mongodb.com/docs/manual/core/capped-collections)\n   * you may use a Tailable Cursor that remains open after the client exhausts\n   * the results in the initial cursor.\n   */\n  tailable?: boolean;\n  /**\n   * If awaitData is set to true, when the cursor reaches the end of the capped collection,\n   * MongoDB blocks the query thread for a period of time waiting for new data to arrive.\n   * When new data is inserted into the capped collection, the blocked thread is signaled\n   * to wake up and return the next batch to the client.\n   */\n  awaitData?: boolean;\n  noCursorTimeout?: boolean;\n  /** @internal TODO(NODE-5688): make this public */\n  timeoutMS?: number;\n}\n\n/** @internal */\nexport type InternalAbstractCursorOptions = Omit<AbstractCursorOptions, 'readPreference'> & {\n  // resolved\n  readPreference: ReadPreference;\n  readConcern?: ReadConcern;\n\n  // cursor flags, some are deprecated\n  oplogReplay?: boolean;\n  exhaust?: boolean;\n  partial?: boolean;\n};\n\n/** @public */\nexport type AbstractCursorEvents = {\n  [AbstractCursor.CLOSE](): void;\n};\n\n/** @public */\nexport abstract class AbstractCursor<\n    TSchema = any,\n    CursorEvents extends AbstractCursorEvents = AbstractCursorEvents\n  >\n  extends TypedEventEmitter<CursorEvents>\n  implements AsyncDisposable\n{\n  /** @internal */\n  private cursorId: Long | null;\n  /** @internal */\n  private cursorSession: ClientSession;\n  /** @internal */\n  private selectedServer?: Server;\n  /** @internal */\n  private cursorNamespace: MongoDBNamespace;\n  /** @internal */\n  private documents: CursorResponse | null = null;\n  /** @internal */\n  private cursorClient: MongoClient;\n  /** @internal */\n  private transform?: (doc: TSchema) => any;\n  /** @internal */\n  private initialized: boolean;\n  /** @internal */\n  private isClosed: boolean;\n  /** @internal */\n  private isKilled: boolean;\n  /** @internal */\n  protected readonly cursorOptions: InternalAbstractCursorOptions;\n\n  /** @event */\n  static readonly CLOSE = 'close' as const;\n\n  /** @internal */\n  protected deserializationOptions: OnDemandDocumentDeserializeOptions;\n\n  /** @internal */\n  protected constructor(\n    client: MongoClient,\n    namespace: MongoDBNamespace,\n    options: AbstractCursorOptions = {}\n  ) {\n    super();\n\n    if (!client.s.isMongoClient) {\n      throw new MongoRuntimeError('Cursor must be constructed with MongoClient');\n    }\n    this.cursorClient = client;\n    this.cursorNamespace = namespace;\n    this.cursorId = null;\n    this.initialized = false;\n    this.isClosed = false;\n    this.isKilled = false;\n    this.cursorOptions = {\n      readPreference:\n        options.readPreference && options.readPreference instanceof ReadPreference\n          ? options.readPreference\n          : ReadPreference.primary,\n      ...pluckBSONSerializeOptions(options)\n    };\n    this.cursorOptions.timeoutMS = options.timeoutMS;\n\n    const readConcern = ReadConcern.fromOptions(options);\n    if (readConcern) {\n      this.cursorOptions.readConcern = readConcern;\n    }\n\n    if (typeof options.batchSize === 'number') {\n      this.cursorOptions.batchSize = options.batchSize;\n    }\n\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (options.comment !== undefined) {\n      this.cursorOptions.comment = options.comment;\n    }\n\n    if (typeof options.maxTimeMS === 'number') {\n      this.cursorOptions.maxTimeMS = options.maxTimeMS;\n    }\n\n    if (typeof options.maxAwaitTimeMS === 'number') {\n      this.cursorOptions.maxAwaitTimeMS = options.maxAwaitTimeMS;\n    }\n\n    if (options.session instanceof ClientSession) {\n      this.cursorSession = options.session;\n    } else {\n      this.cursorSession = this.cursorClient.startSession({ owner: this, explicit: false });\n    }\n\n    this.deserializationOptions = {\n      ...this.cursorOptions,\n      validation: {\n        utf8: options?.enableUtf8Validation === false ? false : true\n      }\n    };\n  }\n\n  /**\n   * The cursor has no id until it receives a response from the initial cursor creating command.\n   *\n   * It is non-zero for as long as the database has an open cursor.\n   *\n   * The initiating command may receive a zero id if the entire result is in the `firstBatch`.\n   */\n  get id(): Long | undefined {\n    return this.cursorId ?? undefined;\n  }\n\n  /** @internal */\n  get isDead() {\n    return (this.cursorId?.isZero() ?? false) || this.isClosed || this.isKilled;\n  }\n\n  /** @internal */\n  get client(): MongoClient {\n    return this.cursorClient;\n  }\n\n  /** @internal */\n  get server(): Server | undefined {\n    return this.selectedServer;\n  }\n\n  get namespace(): MongoDBNamespace {\n    return this.cursorNamespace;\n  }\n\n  get readPreference(): ReadPreference {\n    return this.cursorOptions.readPreference;\n  }\n\n  get readConcern(): ReadConcern | undefined {\n    return this.cursorOptions.readConcern;\n  }\n\n  /** @internal */\n  get session(): ClientSession {\n    return this.cursorSession;\n  }\n\n  set session(clientSession: ClientSession) {\n    this.cursorSession = clientSession;\n  }\n\n  /**\n   * The cursor is closed and all remaining locally buffered documents have been iterated.\n   */\n  get closed(): boolean {\n    return this.isClosed && (this.documents?.length ?? 0) === 0;\n  }\n\n  /**\n   * A `killCursors` command was attempted on this cursor.\n   * This is performed if the cursor id is non zero.\n   */\n  get killed(): boolean {\n    return this.isKilled;\n  }\n\n  get loadBalanced(): boolean {\n    return !!this.cursorClient.topology?.loadBalanced;\n  }\n\n  /**\n   * @beta\n   * @experimental\n   * An alias for {@link AbstractCursor.close|AbstractCursor.close()}.\n   */\n  declare [Symbol.asyncDispose]: () => Promise<void>;\n  /** @internal */\n  async asyncDispose() {\n    await this.close();\n  }\n\n  /** Returns current buffered documents length */\n  bufferedCount(): number {\n    return this.documents?.length ?? 0;\n  }\n\n  /** Returns current buffered documents */\n  readBufferedDocuments(number?: number): NonNullable<TSchema>[] {\n    const bufferedDocs: NonNullable<TSchema>[] = [];\n    const documentsToRead = Math.min(\n      number ?? this.documents?.length ?? 0,\n      this.documents?.length ?? 0\n    );\n\n    for (let count = 0; count < documentsToRead; count++) {\n      const document = this.documents?.shift(this.deserializationOptions);\n      if (document != null) {\n        bufferedDocs.push(document);\n      }\n    }\n\n    return bufferedDocs;\n  }\n\n  async *[Symbol.asyncIterator](): AsyncGenerator<TSchema, void, void> {\n    if (this.closed) {\n      return;\n    }\n\n    try {\n      while (true) {\n        if (this.isKilled) {\n          return;\n        }\n\n        if (this.closed) {\n          return;\n        }\n\n        if (this.cursorId != null && this.isDead && (this.documents?.length ?? 0) === 0) {\n          return;\n        }\n\n        const document = await this.next();\n\n        // eslint-disable-next-line no-restricted-syntax\n        if (document === null) {\n          return;\n        }\n\n        yield document;\n      }\n    } finally {\n      // Only close the cursor if it has not already been closed. This finally clause handles\n      // the case when a user would break out of a for await of loop early.\n      if (!this.isClosed) {\n        try {\n          await this.close();\n        } catch (error) {\n          squashError(error);\n        }\n      }\n    }\n  }\n\n  stream(options?: CursorStreamOptions): Readable & AsyncIterable<TSchema> {\n    if (options?.transform) {\n      const transform = options.transform;\n      const readable = new ReadableCursorStream(this);\n\n      const transformedStream = readable.pipe(\n        new Transform({\n          objectMode: true,\n          highWaterMark: 1,\n          transform(chunk, _, callback) {\n            try {\n              const transformed = transform(chunk);\n              callback(undefined, transformed);\n            } catch (err) {\n              callback(err);\n            }\n          }\n        })\n      );\n\n      // Bubble errors to transformed stream, because otherwise no way\n      // to handle this error.\n      readable.on('error', err => transformedStream.emit('error', err));\n\n      return transformedStream;\n    }\n\n    return new ReadableCursorStream(this);\n  }\n\n  async hasNext(): Promise<boolean> {\n    if (this.cursorId === Long.ZERO) {\n      return false;\n    }\n\n    do {\n      if ((this.documents?.length ?? 0) !== 0) {\n        return true;\n      }\n      await this.fetchBatch();\n    } while (!this.isDead || (this.documents?.length ?? 0) !== 0);\n\n    return false;\n  }\n\n  /** Get the next available document from the cursor, returns null if no more documents are available. */\n  async next(): Promise<TSchema | null> {\n    if (this.cursorId === Long.ZERO) {\n      throw new MongoCursorExhaustedError();\n    }\n\n    do {\n      const doc = this.documents?.shift(this.deserializationOptions);\n      if (doc != null) {\n        if (this.transform != null) return await this.transformDocument(doc);\n        return doc;\n      }\n      await this.fetchBatch();\n    } while (!this.isDead || (this.documents?.length ?? 0) !== 0);\n\n    return null;\n  }\n\n  /**\n   * Try to get the next available document from the cursor or `null` if an empty batch is returned\n   */\n  async tryNext(): Promise<TSchema | null> {\n    if (this.cursorId === Long.ZERO) {\n      throw new MongoCursorExhaustedError();\n    }\n\n    let doc = this.documents?.shift(this.deserializationOptions);\n    if (doc != null) {\n      if (this.transform != null) return await this.transformDocument(doc);\n      return doc;\n    }\n\n    await this.fetchBatch();\n\n    doc = this.documents?.shift(this.deserializationOptions);\n    if (doc != null) {\n      if (this.transform != null) return await this.transformDocument(doc);\n      return doc;\n    }\n\n    return null;\n  }\n\n  /**\n   * Iterates over all the documents for this cursor using the iterator, callback pattern.\n   *\n   * If the iterator returns `false`, iteration will stop.\n   *\n   * @param iterator - The iteration callback.\n   * @deprecated - Will be removed in a future release. Use for await...of instead.\n   */\n  async forEach(iterator: (doc: TSchema) => boolean | void): Promise<void> {\n    if (typeof iterator !== 'function') {\n      throw new MongoInvalidArgumentError('Argument \"iterator\" must be a function');\n    }\n    for await (const document of this) {\n      const result = iterator(document);\n      if (result === false) {\n        break;\n      }\n    }\n  }\n\n  /**\n   * Frees any client-side resources used by the cursor.\n   */\n  async close(): Promise<void> {\n    await this.cleanup();\n  }\n\n  /**\n   * Returns an array of documents. The caller is responsible for making sure that there\n   * is enough memory to store the results. Note that the array only contains partial\n   * results when this cursor had been previously accessed. In that case,\n   * cursor.rewind() can be used to reset the cursor.\n   */\n  async toArray(): Promise<TSchema[]> {\n    const array: TSchema[] = [];\n    // at the end of the loop (since readBufferedDocuments is called) the buffer will be empty\n    // then, the 'await of' syntax will run a getMore call\n    for await (const document of this) {\n      array.push(document);\n      const docs = this.readBufferedDocuments();\n      if (this.transform != null) {\n        for (const doc of docs) {\n          array.push(await this.transformDocument(doc));\n        }\n      } else {\n        array.push(...docs);\n      }\n    }\n    return array;\n  }\n  /**\n   * Add a cursor flag to the cursor\n   *\n   * @param flag - The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial' -.\n   * @param value - The flag boolean value.\n   */\n  addCursorFlag(flag: CursorFlag, value: boolean): this {\n    this.throwIfInitialized();\n    if (!CURSOR_FLAGS.includes(flag)) {\n      throw new MongoInvalidArgumentError(`Flag ${flag} is not one of ${CURSOR_FLAGS}`);\n    }\n\n    if (typeof value !== 'boolean') {\n      throw new MongoInvalidArgumentError(`Flag ${flag} must be a boolean value`);\n    }\n\n    this.cursorOptions[flag] = value;\n    return this;\n  }\n\n  /**\n   * Map all documents using the provided function\n   * If there is a transform set on the cursor, that will be called first and the result passed to\n   * this function's transform.\n   *\n   * @remarks\n   *\n   * **Note** Cursors use `null` internally to indicate that there are no more documents in the cursor. Providing a mapping\n   * function that maps values to `null` will result in the cursor closing itself before it has finished iterating\n   * all documents.  This will **not** result in a memory leak, just surprising behavior.  For example:\n   *\n   * ```typescript\n   * const cursor = collection.find({});\n   * cursor.map(() => null);\n   *\n   * const documents = await cursor.toArray();\n   * // documents is always [], regardless of how many documents are in the collection.\n   * ```\n   *\n   * Other falsey values are allowed:\n   *\n   * ```typescript\n   * const cursor = collection.find({});\n   * cursor.map(() => '');\n   *\n   * const documents = await cursor.toArray();\n   * // documents is now an array of empty strings\n   * ```\n   *\n   * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\n   * it **does not** return a new instance of a cursor. This means when calling map,\n   * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\n   * Take note of the following example:\n   *\n   * @example\n   * ```typescript\n   * const cursor: FindCursor<Document> = coll.find();\n   * const mappedCursor: FindCursor<number> = cursor.map(doc => Object.keys(doc).length);\n   * const keyCounts: number[] = await mappedCursor.toArray(); // cursor.toArray() still returns Document[]\n   * ```\n   * @param transform - The mapping transformation method.\n   */\n  map<T = any>(transform: (doc: TSchema) => T): AbstractCursor<T> {\n    this.throwIfInitialized();\n    const oldTransform = this.transform;\n    if (oldTransform) {\n      this.transform = doc => {\n        return transform(oldTransform(doc));\n      };\n    } else {\n      this.transform = transform;\n    }\n\n    return this as unknown as AbstractCursor<T>;\n  }\n\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n  withReadPreference(readPreference: ReadPreferenceLike): this {\n    this.throwIfInitialized();\n    if (readPreference instanceof ReadPreference) {\n      this.cursorOptions.readPreference = readPreference;\n    } else if (typeof readPreference === 'string') {\n      this.cursorOptions.readPreference = ReadPreference.fromString(readPreference);\n    } else {\n      throw new MongoInvalidArgumentError(`Invalid read preference: ${readPreference}`);\n    }\n\n    return this;\n  }\n\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n  withReadConcern(readConcern: ReadConcernLike): this {\n    this.throwIfInitialized();\n    const resolvedReadConcern = ReadConcern.fromOptions({ readConcern });\n    if (resolvedReadConcern) {\n      this.cursorOptions.readConcern = resolvedReadConcern;\n    }\n\n    return this;\n  }\n\n  /**\n   * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)\n   *\n   * @param value - Number of milliseconds to wait before aborting the query.\n   */\n  maxTimeMS(value: number): this {\n    this.throwIfInitialized();\n    if (typeof value !== 'number') {\n      throw new MongoInvalidArgumentError('Argument for maxTimeMS must be a number');\n    }\n\n    this.cursorOptions.maxTimeMS = value;\n    return this;\n  }\n\n  /**\n   * Set the batch size for the cursor.\n   *\n   * @param value - The number of documents to return per batch. See {@link https://www.mongodb.com/docs/manual/reference/command/find/|find command documentation}.\n   */\n  batchSize(value: number): this {\n    this.throwIfInitialized();\n    if (this.cursorOptions.tailable) {\n      throw new MongoTailableCursorError('Tailable cursor does not support batchSize');\n    }\n\n    if (typeof value !== 'number') {\n      throw new MongoInvalidArgumentError('Operation \"batchSize\" requires an integer');\n    }\n\n    this.cursorOptions.batchSize = value;\n    return this;\n  }\n\n  /**\n   * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will\n   * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even\n   * if the resultant data has already been retrieved by this cursor.\n   */\n  rewind(): void {\n    if (!this.initialized) {\n      return;\n    }\n\n    this.cursorId = null;\n    this.documents?.clear();\n    this.isClosed = false;\n    this.isKilled = false;\n    this.initialized = false;\n\n    const session = this.cursorSession;\n    if (session) {\n      // We only want to end this session if we created it, and it hasn't ended yet\n      if (session.explicit === false) {\n        if (!session.hasEnded) {\n          session.endSession().then(undefined, squashError);\n        }\n        this.cursorSession = this.cursorClient.startSession({ owner: this, explicit: false });\n      }\n    }\n  }\n\n  /**\n   * Returns a new uninitialized copy of this cursor, with options matching those that have been set on the current instance\n   */\n  abstract clone(): AbstractCursor<TSchema>;\n\n  /** @internal */\n  protected abstract _initialize(\n    session: ClientSession | undefined\n  ): Promise<InitialCursorResponse>;\n\n  /** @internal */\n  async getMore(batchSize: number): Promise<CursorResponse> {\n    if (this.cursorId == null) {\n      throw new MongoRuntimeError(\n        'Unexpected null cursor id. A cursor creating command should have set this'\n      );\n    }\n    if (this.selectedServer == null) {\n      throw new MongoRuntimeError(\n        'Unexpected null selectedServer. A cursor creating command should have set this'\n      );\n    }\n    const getMoreOperation = new GetMoreOperation(\n      this.cursorNamespace,\n      this.cursorId,\n      this.selectedServer,\n      {\n        ...this.cursorOptions,\n        session: this.cursorSession,\n        batchSize\n      }\n    );\n\n    return await executeOperation(this.cursorClient, getMoreOperation);\n  }\n\n  /**\n   * @internal\n   *\n   * This function is exposed for the unified test runner's createChangeStream\n   * operation.  We cannot refactor to use the abstract _initialize method without\n   * a significant refactor.\n   */\n  private async cursorInit(): Promise<void> {\n    try {\n      const state = await this._initialize(this.cursorSession);\n      const response = state.response;\n      this.selectedServer = state.server;\n      this.cursorId = response.id;\n      this.cursorNamespace = response.ns ?? this.namespace;\n      this.documents = response;\n      this.initialized = true; // the cursor is now initialized, even if it is dead\n    } catch (error) {\n      // the cursor is now initialized, even if an error occurred\n      this.initialized = true;\n      await this.cleanup(error);\n      throw error;\n    }\n\n    if (this.isDead) {\n      await this.cleanup();\n    }\n\n    return;\n  }\n\n  /** @internal Attempt to obtain more documents */\n  private async fetchBatch(): Promise<void> {\n    if (this.isClosed) {\n      return;\n    }\n\n    if (this.isDead) {\n      // if the cursor is dead, we clean it up\n      // cleanupCursor should never throw, but if it does it indicates a bug in the driver\n      // and we should surface the error\n      await this.cleanup();\n      return;\n    }\n\n    if (this.cursorId == null) {\n      await this.cursorInit();\n      // If the cursor died or returned documents, return\n      if ((this.documents?.length ?? 0) !== 0 || this.isDead) return;\n      // Otherwise, run a getMore\n    }\n\n    // otherwise need to call getMore\n    const batchSize = this.cursorOptions.batchSize || 1000;\n\n    try {\n      const response = await this.getMore(batchSize);\n      this.cursorId = response.id;\n      this.documents = response;\n    } catch (error) {\n      try {\n        await this.cleanup(error);\n      } catch (error) {\n        // `cleanupCursor` should never throw, squash and throw the original error\n        squashError(error);\n      }\n      throw error;\n    }\n\n    if (this.isDead) {\n      // If we successfully received a response from a cursor BUT the cursor indicates that it is exhausted,\n      // we intentionally clean up the cursor to release its session back into the pool before the cursor\n      // is iterated.  This prevents a cursor that is exhausted on the server from holding\n      // onto a session indefinitely until the AbstractCursor is iterated.\n      //\n      // cleanupCursorAsync should never throw, but if it does it indicates a bug in the driver\n      // and we should surface the error\n      await this.cleanup();\n    }\n  }\n\n  /** @internal */\n  private async cleanup(error?: Error) {\n    this.isClosed = true;\n    const session = this.cursorSession;\n    try {\n      if (\n        !this.isKilled &&\n        this.cursorId &&\n        !this.cursorId.isZero() &&\n        this.cursorNamespace &&\n        this.selectedServer &&\n        !session.hasEnded\n      ) {\n        this.isKilled = true;\n        const cursorId = this.cursorId;\n        this.cursorId = Long.ZERO;\n        await executeOperation(\n          this.cursorClient,\n          new KillCursorsOperation(cursorId, this.cursorNamespace, this.selectedServer, {\n            session\n          })\n        );\n      }\n    } catch (error) {\n      squashError(error);\n    } finally {\n      if (session?.owner === this) {\n        await session.endSession({ error });\n      }\n      if (!session?.inTransaction()) {\n        maybeClearPinnedConnection(session, { error });\n      }\n\n      this.emitClose();\n    }\n  }\n\n  /** @internal */\n  private hasEmittedClose = false;\n  /** @internal */\n  private emitClose() {\n    try {\n      if (!this.hasEmittedClose && ((this.documents?.length ?? 0) === 0 || this.isClosed)) {\n        // @ts-expect-error: CursorEvents is generic so Parameters<CursorEvents[\"close\"]> may not be assignable to `[]`. Not sure how to require extenders do not add parameters.\n        this.emit('close');\n      }\n    } finally {\n      this.hasEmittedClose = true;\n    }\n  }\n\n  /** @internal */\n  private async transformDocument(document: NonNullable<TSchema>): Promise<NonNullable<TSchema>> {\n    if (this.transform == null) return document;\n\n    try {\n      const transformedDocument = this.transform(document);\n      // eslint-disable-next-line no-restricted-syntax\n      if (transformedDocument === null) {\n        const TRANSFORM_TO_NULL_ERROR =\n          'Cursor returned a `null` document, but the cursor is not exhausted.  Mapping documents to `null` is not supported in the cursor transform.';\n        throw new MongoAPIError(TRANSFORM_TO_NULL_ERROR);\n      }\n      return transformedDocument;\n    } catch (transformError) {\n      try {\n        await this.close();\n      } catch (closeError) {\n        squashError(closeError);\n      }\n      throw transformError;\n    }\n  }\n\n  /** @internal */\n  protected throwIfInitialized() {\n    if (this.initialized) throw new MongoCursorInUseError();\n  }\n}\n\nclass ReadableCursorStream extends Readable {\n  private _cursor: AbstractCursor;\n  private _readInProgress = false;\n\n  constructor(cursor: AbstractCursor) {\n    super({\n      objectMode: true,\n      autoDestroy: false,\n      highWaterMark: 1\n    });\n    this._cursor = cursor;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  override _read(size: number): void {\n    if (!this._readInProgress) {\n      this._readInProgress = true;\n      this._readNext();\n    }\n  }\n\n  override _destroy(error: Error | null, callback: (error?: Error | null) => void): void {\n    this._cursor.close().then(\n      () => callback(error),\n      closeError => callback(closeError)\n    );\n  }\n\n  private _readNext() {\n    if (this._cursor.id === Long.ZERO) {\n      this.push(null);\n      return;\n    }\n\n    this._cursor.next().then(\n      result => {\n        if (result == null) {\n          this.push(null);\n        } else if (this.destroyed) {\n          this._cursor.close().then(undefined, squashError);\n        } else {\n          if (this.push(result)) {\n            return this._readNext();\n          }\n\n          this._readInProgress = false;\n        }\n      },\n      err => {\n        // NOTE: This is questionable, but we have a test backing the behavior. It seems the\n        //       desired behavior is that a stream ends cleanly when a user explicitly closes\n        //       a client during iteration. Alternatively, we could do the \"right\" thing and\n        //       propagate the error message by removing this special case.\n        if (err.message.match(/server is closed/)) {\n          this._cursor.close().then(undefined, squashError);\n          return this.push(null);\n        }\n\n        // NOTE: This is also perhaps questionable. The rationale here is that these errors tend\n        //       to be \"operation was interrupted\", where a cursor has been closed but there is an\n        //       active getMore in-flight. This used to check if the cursor was killed but once\n        //       that changed to happen in cleanup legitimate errors would not destroy the\n        //       stream. There are change streams test specifically test these cases.\n        if (err.message.match(/operation was interrupted/)) {\n          return this.push(null);\n        }\n\n        // NOTE: The two above checks on the message of the error will cause a null to be pushed\n        //       to the stream, thus closing the stream before the destroy call happens. This means\n        //       that either of those error messages on a change stream will not get a proper\n        //       'error' event to be emitted (the error passed to destroy). Change stream resumability\n        //       relies on that error event to be emitted to create its new cursor and thus was not\n        //       working on 4.4 servers because the error emitted on failover was \"interrupted at\n        //       shutdown\" while on 5.0+ it is \"The server is in quiesce mode and will shut down\".\n        //       See NODE-4475.\n        return this.destroy(err);\n      }\n    );\n  }\n}\n\nconfigureResourceManagement(AbstractCursor.prototype);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}